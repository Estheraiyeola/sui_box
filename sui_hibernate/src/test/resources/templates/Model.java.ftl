<#-- templates/Model.java.ftl -->
package ${package};

import java.lang.reflect.*;
import io.sui.models.transactions.TransactionBlockResponse;
import java.util.List;
import java.util.Map;
import java.util.HashMap;
import java.util.concurrent.CompletableFuture;
import org.example.blockchain.SuiContractManager;
import org.example.models.generated.AutoGeneratedModel;

/**
* Auto-generated bridge for on-chain struct `${className}`.
*/
@AutoGeneratedModel(structName="${className}")
public class ${className} {
    private final String objectId;
    private final SuiContractManager mgr;

    <#list fields as field>
        private ${field.javaType} ${field.name};
    </#list>

    private ${className}(String objectId, SuiContractManager mgr) {
        this.objectId = objectId;
        this.mgr = mgr;
    }

    // Standard getters/setters
    <#list fields as field>
        public ${field.javaType} get${field.name?cap_first}() { return this.${field.name}; }
        public void set${field.name?cap_first}(${field.javaType} v) { this.${field.name} = v; }
    </#list>

    public String getObjectId() { return objectId; }

    // Create and populate new on-chain object
    public static CompletableFuture<${className}> create(
        SuiContractManager mgr,
        <#list fields as field>
            ${field.javaType} ${field.name}<#if field_has_next>,</#if>
        </#list>
        ) {
            return mgr.executeMoveCall(
            mgr.getPackageId(),
            "${className}",
            "new",
            List.of(
            <#list fields as field>
                ${field.name}<#if field_has_next>,</#if>
            </#list>
            )
            ).thenApply(resp -> {
            String id = resp.getEffects()
            .getCreated().get(0)
            .getReference().getObjectId();
            ${className} m = new ${className}(id, mgr);
            <#list fields as field>
                m.set${field.name?cap_first}(${field.name});
            </#list>
            return m;
        });
        }

    // Reflection‚Äêdriven registry of all generated models
    private static final Map<String, Class<?>> registry = new HashMap<>();
        static {
        // e.g. registry.put("Bar", BarModel.class); -- real code can scan package
        registry.put("${className}", ${className}.class);
    }

    public static Class<?> findModelClass(String structName) {
        return registry.get(structName);
    }

    // ... more wrappers for update, delete, queryAttribute, etc. ...
    }
